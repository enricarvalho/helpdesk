const Chamado = require('../models/Chamado');

class AIService {
  constructor() {
    // Base de conhecimento para an√°lise de padr√µes
    this.knowledgeBase = {
      // Padr√µes de problemas comuns e suas solu√ß√µes
      patterns: [
        {
          keywords: ['senha', 'login', 'acesso', 'entrar', 'bloqueado'],
          category: 'Autentica√ß√£o',
          solutions: [
            'Redefinir senha atrav√©s do sistema',
            'Verificar se o usu√°rio est√° ativo no sistema',
            'Limpar cache do navegador',
            'Verificar se caps lock est√° ativado',
            'Contatar administrador para desbloqueio'
          ],
          priority: 'Alta',
          estimatedTime: '15-30 minutos'
        },
        {
          keywords: ['internet', 'rede', 'wifi', 'conex√£o', 'lento'],
          category: 'Conectividade',
          solutions: [
            'Verificar cabo de rede',
            'Reiniciar roteador/modem',
            'Verificar configura√ß√µes de DNS',
            'Executar diagn√≥stico de rede',
            'Contatar provedor de internet'
          ],
          priority: 'M√©dia',
          estimatedTime: '30-60 minutos'
        },
        {
          keywords: ['impressora', 'imprimir', 'papel', 'toner', 'scanner'],
          category: 'Impress√£o',
          solutions: [
            'Verificar se h√° papel na impressora',
            'Verificar n√≠vel de toner/tinta',
            'Reinstalar driver da impressora',
            'Limpar fila de impress√£o',
            'Verificar conex√£o USB/rede da impressora'
          ],
          priority: 'Baixa',
          estimatedTime: '20-45 minutos'
        },
        {
          keywords: ['email', 'outlook', 'envio', 'recebimento', 'anexo'],
          category: 'Email',
          solutions: [
            'Verificar configura√ß√µes de servidor',
            'Verificar caixa de spam',
            'Reconfigurar conta de email',
            'Verificar cota de armazenamento',
            'Verificar tamanho dos anexos'
          ],
          priority: 'M√©dia',
          estimatedTime: '25-40 minutos'
        },
        {
          keywords: ['sistema', 'erro', 'travando', 'lento', 'aplicativo'],
          category: 'Software',
          solutions: [
            'Reiniciar o aplicativo',
            'Verificar atualiza√ß√µes dispon√≠veis',
            'Limpar arquivos tempor√°rios',
            'Verificar espa√ßo em disco',
            'Executar antiv√≠rus'
          ],
          priority: 'M√©dia',
          estimatedTime: '30-90 minutos'
        },
        {
          keywords: ['hardware', 'monitor', 'teclado', 'mouse', 'cabo'],
          category: 'Hardware',
          solutions: [
            'Verificar todas as conex√µes',
            'Testar em outro computador',
            'Verificar drivers do dispositivo',
            'Limpar contatos/conectores',
            'Substituir cabo se necess√°rio'
          ],
          priority: 'Alta',
          estimatedTime: '45-120 minutos'
        }
      ]
    };
  }

  // Analisa um chamado e retorna sugest√µes de IA
  async analyzeChamado(chamado) {
    try {
      console.log('ü§ñ AI: Analisando chamado:', chamado.titulo);

      // Combinar t√≠tulo e descri√ß√£o para an√°lise
      const text = `${chamado.titulo} ${chamado.descricao}`.toLowerCase();

      // Encontrar padr√µes correspondentes
      const matchedPatterns = this.findMatchingPatterns(text);

      // Buscar chamados similares resolvidos
      const similarChamados = await this.findSimilarResolvedChamados(text, chamado._id);

      // Analisar hist√≥rico do usu√°rio
      const userHistory = await this.analyzeUserHistory(chamado.usuario);

      // Gerar sugest√µes baseadas nos padr√µes encontrados
      const suggestions = this.generateSuggestions(matchedPatterns, similarChamados, userHistory);

      // Calcular confian√ßa da an√°lise
      const confidence = this.calculateConfidence(matchedPatterns, similarChamados);

      return {
        analysis: {
          detectedCategory: matchedPatterns.length > 0 ? matchedPatterns[0].category : 'Geral',
          confidence: confidence,
          suggestedPriority: this.suggestPriority(matchedPatterns, chamado.prioridade),
          estimatedResolutionTime: this.estimateResolutionTime(matchedPatterns)
        },
        suggestions: suggestions,
        similarCases: similarChamados.slice(0, 3), // Top 3 casos similares
        userInsights: userHistory,
        createdAt: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Erro na an√°lise de IA:', error);
      return {
        analysis: {
          detectedCategory: 'Geral',
          confidence: 0,
          suggestedPriority: chamado.prioridade,
          estimatedResolutionTime: 'N√£o estimado'
        },
        suggestions: ['An√°lise manual necess√°ria'],
        similarCases: [],
        userInsights: {},
        error: 'Erro na an√°lise de IA',
        createdAt: new Date().toISOString()
      };
    }
  }

  // Encontra padr√µes correspondentes no texto
  findMatchingPatterns(text) {
    return this.knowledgeBase.patterns.filter(pattern => {
      const matchCount = pattern.keywords.filter(keyword => 
        text.includes(keyword)
      ).length;
      return matchCount > 0;
    }).sort((a, b) => {
      // Ordenar por n√∫mero de palavras-chave correspondentes
      const aMatches = a.keywords.filter(k => text.includes(k)).length;
      const bMatches = b.keywords.filter(k => text.includes(k)).length;
      return bMatches - aMatches;
    });
  }

  // Busca chamados similares j√° resolvidos
  async findSimilarResolvedChamados(text, currentChamadoId) {
    try {
      const chamados = await Chamado.find({
        _id: { $ne: currentChamadoId },
        status: { $in: ['Resolvido', 'Fechado'] },
        comentarioResolucao: { $exists: true, $ne: '' }
      }).limit(10).populate('usuario', 'nome email');

      // Calcular similaridade baseada em palavras-chave
      const keywords = text.split(' ').filter(word => word.length > 3);
      
      return chamados.map(chamado => {
        const chamadoText = `${chamado.titulo} ${chamado.descricao}`.toLowerCase();
        const similarity = this.calculateTextSimilarity(text, chamadoText);
        
        return {
          id: chamado._id,
          titulo: chamado.titulo,
          categoria: chamado.categoria,
          resolucao: chamado.comentarioResolucao,
          tempoResolucao: this.calculateResolutionTime(chamado),
          similarity: similarity
        };
      }).filter(item => item.similarity > 0.1)
        .sort((a, b) => b.similarity - a.similarity);

    } catch (error) {
      console.error('Erro ao buscar chamados similares:', error);
      return [];
    }
  }

  // Analisa hist√≥rico do usu√°rio
  async analyzeUserHistory(usuarioId) {
    try {
      const chamados = await Chamado.find({
        usuario: usuarioId
      }).sort({ criadoEm: -1 }).limit(10);

      const totalChamados = chamados.length;
      const chamadosResolvidos = chamados.filter(c => c.status === 'Resolvido').length;
      const categorias = [...new Set(chamados.map(c => c.categoria))];
      const tempoMedioResolucao = this.calculateAverageResolutionTime(chamados);

      return {
        totalChamados,
        chamadosResolvidos,
        taxaResolucao: totalChamados > 0 ? (chamadosResolvidos / totalChamados * 100).toFixed(1) : 0,
        categoriasMaisComuns: categorias.slice(0, 3),
        tempoMedioResolucao,
        usuarioRecorrente: totalChamados > 5
      };

    } catch (error) {
      console.error('Erro ao analisar hist√≥rico do usu√°rio:', error);
      return {};
    }
  }

  // Gera sugest√µes baseadas na an√°lise
  generateSuggestions(patterns, similarCases, userHistory) {
    const suggestions = [];

    // Sugest√µes baseadas em padr√µes
    if (patterns.length > 0) {
      const topPattern = patterns[0];
      suggestions.push(...topPattern.solutions.slice(0, 3));
    }

    // Sugest√µes baseadas em casos similares
    if (similarCases.length > 0) {
      const topSimilar = similarCases[0];
      if (topSimilar.resolucao && topSimilar.similarity > 0.3) {
        suggestions.push(`Solu√ß√£o similar: ${topSimilar.resolucao}`);
      }
    }

    // Sugest√µes baseadas no hist√≥rico do usu√°rio
    if (userHistory.usuarioRecorrente) {
      suggestions.push('Usu√°rio recorrente - considerar treinamento espec√≠fico');
    }

    // Sugest√µes gerais se n√£o houver padr√µes
    if (suggestions.length === 0) {
      suggestions.push(
        'Coletar mais informa√ß√µes sobre o problema',
        'Verificar se o problema √© reproduz√≠vel',
        'Documentar passos para reproduzir o erro'
      );
    }

    return [...new Set(suggestions)]; // Remove duplicatas
  }

  // Calcula confian√ßa da an√°lise
  calculateConfidence(patterns, similarCases) {
    let confidence = 0;

    if (patterns.length > 0) {
      confidence += 0.4; // 40% se encontrou padr√µes
    }

    if (similarCases.length > 0) {
      confidence += 0.3; // 30% se encontrou casos similares
      if (similarCases[0]?.similarity > 0.5) {
        confidence += 0.2; // +20% se muito similar
      }
    }

    confidence += Math.min(patterns.length * 0.1, 0.3); // +10% por padr√£o adicional (m√°x 30%)

    return Math.min(confidence * 100, 95); // M√°ximo 95% de confian√ßa
  }

  // Sugere prioridade baseada na an√°lise
  suggestPriority(patterns, currentPriority) {
    if (patterns.length === 0) return currentPriority;

    const suggestedPriorities = patterns.map(p => p.priority);
    const priorityMap = { 'Baixa': 1, 'M√©dia': 2, 'Alta': 3, 'Urgente': 4 };

    const avgPriority = suggestedPriorities.reduce((sum, p) => sum + priorityMap[p], 0) / suggestedPriorities.length;

    if (avgPriority >= 3.5) return 'Urgente';
    if (avgPriority >= 2.5) return 'Alta';
    if (avgPriority >= 1.5) return 'M√©dia';
    return 'Baixa';
  }

  // Estima tempo de resolu√ß√£o
  estimateResolutionTime(patterns) {
    if (patterns.length === 0) return 'N√£o estimado';
    return patterns[0].estimatedTime;
  }

  // Calcula similaridade entre textos (algoritmo simples)
  calculateTextSimilarity(text1, text2) {
    const words1 = new Set(text1.split(' ').filter(w => w.length > 3));
    const words2 = new Set(text2.split(' ').filter(w => w.length > 3));
    
    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);
    
    return union.size > 0 ? intersection.size / union.size : 0;
  }

  // Calcula tempo de resolu√ß√£o de um chamado
  calculateResolutionTime(chamado) {
    if (!chamado.criadoEm || !chamado.updatedAt) return null;
    
    const created = new Date(chamado.criadoEm);
    const resolved = new Date(chamado.updatedAt);
    const diffHours = Math.abs(resolved - created) / 36e5;
    
    return diffHours.toFixed(1) + ' horas';
  }

  // Calcula tempo m√©dio de resolu√ß√£o
  calculateAverageResolutionTime(chamados) {
    const resolvedChamados = chamados.filter(c => c.status === 'Resolvido' && c.criadoEm && c.updatedAt);
    
    if (resolvedChamados.length === 0) return 'N/A';
    
    const totalHours = resolvedChamados.reduce((sum, chamado) => {
      const diffHours = Math.abs(new Date(chamado.updatedAt) - new Date(chamado.criadoEm)) / 36e5;
      return sum + diffHours;
    }, 0);
    
    return (totalHours / resolvedChamados.length).toFixed(1) + ' horas';
  }

  // Atualiza base de conhecimento com nova resolu√ß√£o
  async learnFromResolution(chamadoId, resolucao) {
    try {
      const chamado = await Chamado.findById(chamadoId);
      if (!chamado) return;

      // Aqui poderia implementar machine learning para melhorar as sugest√µes
      // Por enquanto, apenas log para futuras implementa√ß√µes
      console.log('üß† AI Learning: Nova resolu√ß√£o registrada para categoria:', chamado.categoria);
      
    } catch (error) {
      console.error('Erro ao aprender com resolu√ß√£o:', error);
    }
  }
}

module.exports = new AIService();
